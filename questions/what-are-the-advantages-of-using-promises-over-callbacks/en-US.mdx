---
title: What are the advantages of using Promises over callbacks?
---

## TL;DR

Promises provide a more readable and maintainable way to handle asynchronous operations compared to callbacks. They help avoid "callback hell" by allowing chaining of operations and provide better error handling through `.catch()`. Promises also integrate well with modern JavaScript features like `async`/`await`.

---

## Advantages of using Promises over callbacks

### Improved readability and maintainability

Promises allow for chaining of asynchronous operations, which makes the code more readable and easier to follow. Instead of nesting multiple callbacks, you can chain `.then()` methods.

```js
// Using callbacks
doSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(finalResult);
    });
  });
});

// Using Promises
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(finalResult));
```

### Avoiding callback hell

Callback hell occurs when multiple nested callbacks make the code difficult to read and maintain. Promises help flatten the structure of the code, making it more linear and easier to understand.

### Better error handling

With callbacks, error handling can become cumbersome as you need to handle errors at each level of the callback chain. Promises provide a `.catch()` method that can handle errors at any point in the chain.

```js
// Using callbacks
doSomething(function (err, result) {
  if (err) {
    handleError(err);
  } else {
    doSomethingElse(result, function (err, newResult) {
      if (err) {
        handleError(err);
      } else {
        doThirdThing(newResult, function (err, finalResult) {
          if (err) {
            handleError(err);
          } else {
            console.log(finalResult);
          }
        });
      }
    });
  }
});

// Using Promises
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(finalResult))
  .catch((err) => handleError(err));
```

### Integration with async/await

Promises integrate seamlessly with the `async`/`await` syntax, which further simplifies asynchronous code and makes it look more like synchronous code.

```js
// Using async/await
async function doAllThings() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(finalResult);
  } catch (err) {
    handleError(err);
  }
}
```

## Further reading

- [MDN Web Docs: Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [JavaScript.info: Promises](https://javascript.info/promise-basics)
- [MDN Web Docs: async/await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await)
